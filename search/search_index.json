{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p> This is the Documentation of the Project of the Green Sprout Team</p>"},{"location":"docs/general/UCRS_FilterMap/","title":"Use-Case-Realization Specification: Filter Map","text":"<p>Version 1.0</p>"},{"location":"docs/general/UCRS_FilterMap/#revision-history","title":"Revision History","text":"Date Version Description Author 27.10.2024 1.0 UCRS for the Filter Map use case Green Sprout Team"},{"location":"docs/general/UCRS_FilterMap/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/UCRS_FilterMap/#11-purpose","title":"1.1 Purpose","text":"<p>The purpose of this Use-Case Realization Specification is to detail the design of the \u201cFilter Map\u201d use case, where a user selects filter criteria on an interactive map, which then displays points of interest that correspond to the filtered properties.</p>"},{"location":"docs/general/UCRS_FilterMap/#12-scope","title":"1.2 Scope","text":"<p>This document covers the interaction flow between the User, Front-End, Back-End, and OpenStreetMap API for filtering and displaying points of interest based on user-selected criteria.</p>"},{"location":"docs/general/UCRS_FilterMap/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms, and Abbreviations","text":"<ul> <li>POI: Point of Interest</li> <li>API: Application Programming Interface</li> <li>n/a: not applicable</li> <li>UCRS : Use-Case-Realization Specification</li> </ul>"},{"location":"docs/general/UCRS_FilterMap/#14-references","title":"1.4 References","text":"<p>n/a</p>"},{"location":"docs/general/UCRS_FilterMap/#15-overview","title":"1.5 Overview","text":"<p>This document is organized into sections detailing the purpose, scope, and flow of events in this use case, followed by derived requirements for implementation.</p>"},{"location":"docs/general/UCRS_FilterMap/#2-flow-of-eventsdesign","title":"2. Flow of Events\u2014Design","text":"<p>The following describes the flow of events in the \"Filter Map\" use case. The sequence diagram is shown below for visual reference:</p> <p></p> <p>Flow Steps: - User Action: The user selects filter keys on the front-end interface to define specific types of points of interest to display on the map. - Front-End Request: The front-end sends a \"request new map\" message to the back end, including the user-selected filter keys. - Back-End to OpenStreetMap API: The back end processes the request and sends a \"request new points of interest\" message to the OpenStreetMap API. This request includes the filter parameters specified by the user. - API Response: The OpenStreetMap API returns data containing the filtered points of interest matching the criteria. - Back-End to Front-End: The back end forwards the received data to the front-end as a \"map\" response. - Map Display: The front-end processes and displays the updated map with the filtered points of interest for the user.</p>"},{"location":"docs/general/UCRS_FilterMap/#3-derived-requirements","title":"3. Derived Requirements","text":"<ol> <li>Real-Time Data: The system should update the map in real-time based on the user's selected filters.</li> <li>Error Handling: If the OpenStreetMap API fails to respond or encounters an error, the system should notify the user and allow them to retry.</li> <li>Scalability: The back end must efficiently handle multiple requests to the OpenStreetMap API without performance degradation.</li> <li>Data Accuracy: The displayed points of interest must accurately reflect the filter criteria selected by the user.</li> </ol>"},{"location":"docs/general/UCRS_ViewRestaurant/","title":"Use-Case-Realization Specification: View Restaurant","text":"<p>Version 1.0</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#revision-history","title":"Revision History","text":"Date Version Description Author 28.10.2024 1.0 UCRS for the Filter Map use case Green Sprout Team"},{"location":"docs/general/UCRS_ViewRestaurant/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/UCRS_ViewRestaurant/#11-purpose","title":"1.1 Purpose","text":"<p>The purpose of this Use-Case Realization Specification is to detail the design of the \u201cView Restaurant\u201d use case, where a user selects a restaurant from the map to see further information and reviews of it.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#12-scope","title":"1.2 Scope","text":"<p>This document covers the interaction flow between the User, Front-End, Back-End, and OpenStreetMap API for filtering and displaying points of interest based on user-selected criteria.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms, and Abbreviations","text":"<ul> <li>POI: Point of Interest</li> <li>API: Application Programming Interface</li> <li>n/a: not applicable</li> <li>UCRS : Use-Case-Realization Specification</li> </ul>"},{"location":"docs/general/UCRS_ViewRestaurant/#14-references","title":"1.4 References","text":"<p>n/a</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#15-overview","title":"1.5 Overview","text":"<p>This document is organized into sections detailing the purpose, scope, and flow of events in this use case, followed by derived requirements for implementation.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#2-flow-of-eventsdesign","title":"2. Flow of Events\u2014Design","text":"<p>The following describes the flow of events in the \"View Restaurant\" use case. The sequence diagram is shown below for visual reference:</p> <p></p> <p>Flow Steps: - User Action: The user clicks on a POI on the Map - Front-End Request: The front-end sends a \"get restaurant info\" request to the back end, including the id of the selected POI. - Back-End to OpenStreetMap API: The back end processes the request and sends a \"request Restaurant info\" request to the OpenStreetMap API. This request includes the id of the selected POI. To load the reviews the backend queries the database (\"request reviews\") using the POI id as well. - API Response: The OpenStreetMap API returns all available information about the requested POI. - Back-End to Front-End: The back combines the data from the OpenStreetMap API and the Database query and sends it back to the frontend (\"display restaurant information\"). - Map Display: The frontend opens the restaurant \"card\" on the left side of the screen and displays the retrieved information.</p>"},{"location":"docs/general/UCRS_ViewRestaurant/#3-derived-requirements","title":"3. Derived Requirements","text":"<ol> <li>Amount of Data: The Backend should only return a certain amount of reviews for this action. To reload more reviews the user just scrolls down the loaded reviews and more will be loaded.</li> <li>Error Handling: If the database query or the OpenStreetMap request fails, the frontend still recieves an answer with the successfully recieved data. If both fail the backend responds with an error message.  </li> <li>Scalability: The back end must efficiently handle multiple requests to the OpenStreetMap API and database queries without performance degradation.  </li> <li>Data Accuracy: The data recieved by the frontend should be displayed accurately without formatting errors.</li> </ol>"},{"location":"docs/general/sad/","title":"SAD (Software Architecture Document)","text":""},{"location":"docs/general/sad/#1-introduction","title":"1. Introduction","text":""},{"location":"docs/general/sad/#11-purpose","title":"1.1 Purpose","text":"<p>This document provides a comprehensive architectural overview of the system, using a number of different architectural views to depict different aspects of the system. It is intended to capture and convey the significant architectural decisions which have been made on the system.</p>"},{"location":"docs/general/sad/#12-scope","title":"1.2 Scope","text":"<p>This Software Architecture Document provides an architectural overview of the Green-Sprout Restaurant Search-and Review System. This Document has been generated under the input of all members participating as part of the Software Engineering project using a Software Architecture Document template.</p>"},{"location":"docs/general/sad/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms and Abbreviations","text":"<p>The following Definitions, Acronyms and Abbreviations are used.:</p> <ul> <li> <p>API  Application Programming Interface</p> </li> <li> <p>CRUD  Short for \"Create, Read, Update and Delete\"</p> </li> <li> <p>JWT  Jason Web Token</p> </li> <li> <p>OSM  Open Street Map</p> </li> <li> <p>ORM  Object-Relational Mapping</p> </li> <li> <p>UML  Unified Modeling Language</p> </li> </ul>"},{"location":"docs/general/sad/#14-references","title":"1.4 References","text":"<p>Applicable references are:</p> <ul> <li> <p>All of the material contained in our Github Repositories</p> </li> <li> <p>https://github.com/green-sprout/backend</p> </li> <li> <p>https://github.com/green-sprout/frontend</p> </li> <li> <p>https://github.com/green-sprout/green-sprout</p> </li> <li> <p>https://github.com/green-sprout/docs</p> </li> </ul>"},{"location":"docs/general/sad/#2-architectural-representation","title":"2. Architectural Representation","text":"<p>This document presents the architecture as a series of views:</p> <ul> <li> <p>Process View</p> </li> <li> <p>Implementation View</p> </li> </ul> <p>The purpose of these views is to relay the structure and function of the Software in a concise manner using UML-Diagrams whenever possible.</p>"},{"location":"docs/general/sad/#3-architectural-goals-and-constraints","title":"3. Architectural Goals and Constraints","text":"<p>The software architecture follows a clear goal of combining user-friendliness and technical requirements. A focus is placed on aesthetics: a uniform, green-colored design system with consistent visual elements and interactive elements improves user-friendliness through direct feedback.</p> <p>Backwards compatibility ensures the easy provision of new versions to guarantee problem-free updates. The performance of the application is optimized by response times of less than 2 seconds, ideally less than 1 second. A Google Page Speed Score of at least 90 points ensures fast loading times.</p> <p>The modular architecture separates backend, frontend and database, which increases maintainability and simplifies future extensions. For security reasons, passwords are hashed and only stored as a hash, while JWT tokens ensure the authentication and integrity of user requests.</p> <p>This architecture ensures a reliable system with a high level of user-friendliness and flexibility.</p>"},{"location":"docs/general/sad/#6-process-view","title":"6. Process View","text":"<p> The sequence diagram shows how a user selects filter criteria via the front end, whereupon the backend retrieves the appropriate map information from the Open Street Map API. The user can select a restaurant whose details and ratings are provided by the backend. They can also write a review, which is saved in the database via the backend.</p>"},{"location":"docs/general/sad/#8-implementation-view","title":"8. Implementation View","text":""},{"location":"docs/general/sad/#komponentendiagramm-der-webanwendung","title":"Komponentendiagramm der Webanwendung","text":""},{"location":"docs/general/sad/#component-diagram-overview","title":"Component Diagram Overview","text":"<p>The component diagram illustrates the architecture of the web application and highlights the main software components and their interactions. The application consists of a frontend and a backend layer that communicate with each other, as well as with external APIs and a database.  </p>"},{"location":"docs/general/sad/#components-and-their-responsibilities","title":"Components and Their Responsibilities","text":""},{"location":"docs/general/sad/#frontend","title":"Frontend","text":"<p>The frontend includes the following components:  </p>"},{"location":"docs/general/sad/#map-view","title":"Map View","text":"<ul> <li>Displays restaurants and map data based on filters selected by the user.  </li> <li>Sends requests to the backend and the OSM integration to update map data.  </li> </ul>"},{"location":"docs/general/sad/#filters","title":"Filters","text":"<ul> <li>Allows users to select search criteria such as cuisine, dietary preferences, or ratings.  </li> <li>Sends the selected filter criteria to the backend and directly to the OSM integration to retrieve filtered data.  </li> </ul>"},{"location":"docs/general/sad/#user-management","title":"User Management","text":"<ul> <li>Handles user registration, login, and session management.  </li> <li>Communicates with the Authentication Service in the backend.  </li> </ul>"},{"location":"docs/general/sad/#review-management","title":"Review Management","text":"<ul> <li>Enables registered users to write reviews and view existing ones.  </li> <li>Submits new or updated reviews to the backend for storage.  </li> </ul>"},{"location":"docs/general/sad/#backend","title":"Backend","text":"<p>The backend includes the following components:  </p>"},{"location":"docs/general/sad/#authentication-service","title":"Authentication Service","text":"<ul> <li>Handles user authentication (login, registration).  </li> <li>Sends and verifies user information in the User Management component.  </li> </ul>"},{"location":"docs/general/sad/#user-management_1","title":"User Management","text":"<ul> <li>Manages user data.  </li> <li>Stores user data in the database via the Database Layer component.  </li> </ul>"},{"location":"docs/general/sad/#osm-integration","title":"OSM Integration","text":"<ul> <li>Communicates with the OpenStreetMap API to fetch map data and restaurant objects.  </li> <li>Processes filter criteria from the frontend and backend to provide filtered data.  </li> <li>Stores restaurant data in the local database when necessary.  </li> </ul>"},{"location":"docs/general/sad/#review-management_1","title":"Review Management","text":"<ul> <li>Handles reviews and ratings received from the frontend.  </li> <li>Stores reviews in the database via the Database Layer component.  </li> </ul>"},{"location":"docs/general/sad/#database-layer","title":"Database Layer","text":"<ul> <li>Serves as the interface to the PostgreSQL database.  </li> <li>Performs CRUD operations (Create, Read, Update, Delete) for user data, reviews, and restaurant data as needed.  </li> </ul>"},{"location":"docs/general/sad/#external-components","title":"External Components","text":""},{"location":"docs/general/sad/#postgresql-database","title":"PostgreSQL Database","text":"<ul> <li>Stores user information, reviews, and, if applicable, restaurant data fetched from the OSM API.  </li> </ul>"},{"location":"docs/general/sad/#openstreetmap-api","title":"OpenStreetMap API","text":"<ul> <li>Provides map data and restaurant information.  </li> <li>Supports filtered requests based on criteria selected by the user.  </li> </ul>"},{"location":"docs/general/sad/#key-interactions","title":"Key Interactions","text":""},{"location":"docs/general/sad/#frontend-to-backend","title":"Frontend to Backend","text":"<ul> <li>User interactions (e.g., filtering, writing reviews) are sent from the frontend to the backend for processing.  </li> <li>Authentication requests and session management are handled by the Authentication Service.  </li> </ul>"},{"location":"docs/general/sad/#backend-to-osm-api","title":"Backend to OSM API","text":"<ul> <li>The backend uses the OSM integration to fetch map data and restaurant information from the OpenStreetMap API.  </li> <li>Filtered requests are forwarded based on the criteria set by the user.  </li> </ul>"},{"location":"docs/general/sad/#backend-to-database","title":"Backend to Database","text":"<ul> <li>User data, reviews, and restaurant data are stored in the PostgreSQL database and retrieved as needed.  </li> </ul>"},{"location":"docs/general/sad/#filters-to-osm-integration","title":"Filters to OSM Integration","text":"<ul> <li>The Filters component in the frontend sends selected criteria directly to the OSM integration to generate a filtered map view.  </li> </ul>"},{"location":"docs/general/sad/#11-quality","title":"11. Quality","text":""},{"location":"docs/general/sad/#extensibility","title":"Extensibility","text":"<p>Vue.js as the front end enables modular and component-based development that can be easily scaled as the number of users and features grow.  </p> <p>The backend in Spring Boot offers a clear separation of model and controller and implements parts of the MVC approach. Services and controllers can be easily extended and exchanged.  </p> <p>By using the OpenStreetMap API in the backend, the use of this API is abstracted and easier to use for the frontend, as filters and regions have to be inserted into the URL for the request to the OpenStreetMap API in a complex manner.</p>"},{"location":"docs/general/sad/#reliability","title":"Reliability","text":"<p>Spring Boot offers solid error handling and logging functions for the early detection and handling of problems.  </p> <p>The PostgreSQL database system ensures data integrity and provides mechanisms for data recovery after failures.  </p> <p>Authentication with JWT provides standardized methods to ensure secure user sessions and minimizes vulnerabilities compared to traditional authentication methods.  </p>"},{"location":"docs/general/sad/#portability","title":"Portability","text":"<p>All components of the system are platform-independent and can be deployed on all platforms and on any infrastructure using containers.  </p>"},{"location":"docs/general/sad/#security","title":"Security","text":"<p>The use of JSON web tokens offers a robust solution for secure and reliable authentication and authorization. Security risks can be minimized by simply adjusting the lifetime of a token.  </p> <p>Accessing the OpenStreetMap API through the backend as a proxy minimizes the security risks of manipulating the request in the frontend to the OpenStreetMap API.  </p> <p>Using an ORM to map and interact with the database eliminates the risks of SQL injections and sniffing.</p>"},{"location":"docs/general/srs/","title":"SRS (Software Requirement Specification)","text":""},{"location":"docs/general/srs/#1-introduction","title":"1 Introduction","text":""},{"location":"docs/general/srs/#11-purpose","title":"1.1 Purpose","text":"<p>This Software Requirement Specification (SRS) provides a comprehensive collection of  all specifications of the \"Green Sprout\" restaurant-finder application. It outlines the  purpose, scope, and key details of the project. The SRS describes both functional and non functional requirements necessary for the development and delivery of the application.</p>"},{"location":"docs/general/srs/#12-scope","title":"1.2 Scope","text":"<p>This project will be a web-based application.  The main actors of this application can include restaurant owners, reviewers, or general  visitors.  The key features planned are:</p> <ul> <li> <p>Visual Map: This map is the primary element of the user interface, displaying the  area (e.g., Karlsruhe) and a set of location markers representing the restaurants at  their respective locations.</p> </li> <li> <p>Restaurant Profiles: Each restaurant has a detailed profile that initially includes its  name, type of cuisine, photos, overall rating, and existing reviews. </p> </li> <li> <p>Registering as a Reviewer: Users can create an account with their first name, last  name, email address and a password of choice. This is necessary to gain the ability  to publish reviews of restaurants and create lists. </p> </li> <li> <p>Creating a Restaurants List: Users can create lists with a title and a collection of  restaurants of their choice.</p> </li> <li> <p>User (Reviewer) Profiles: Registered users have personal profiles featuring their  name, profile picture, and a history of all the reviews they\u2019ve written on the  platform as well as their published restaurant lists.</p> </li> <li> <p>Adding a new Review: Each restaurant on the map will have an \"Add a Review\"  option, allowing users to write a review, upload photos, and provide a star rating.</p> </li> <li> <p>Filtering Restaurant Searches: Users will be able to filter restaurants based on  cuisine type and diet.</p> </li> </ul>"},{"location":"docs/general/srs/#13-definitions-acronyms-and-abbreviations","title":"1.3 Definitions, Acronyms and Abbreviations","text":"Abbreviation Explanation SRS Software Requirement Specification MVP Minimum Viable Product n/a not applicable"},{"location":"docs/general/srs/#14-references","title":"1.4 References","text":"Title Date Publishing Organization Green Sprout Blog Green Sprout Team Green Sprout GitHub Organization Green Sprout Team"},{"location":"docs/general/srs/#15-overview","title":"1.5 Overview","text":"<p>This Software Requirements Specification (SRS) document for the \"Green Sprout\" project  outlines all the requirements necessary for the development of the restaurant-finder application.  It serves as a comprehensive guideline for the design, development, and implementation of the  application.</p> <p>The SRS document is structured to cover both functional and non-functional requirements in  detail. The document is divided into several sections:</p> <p>Section 1 introduces the project, covering its purpose, scope, and relevant definitions. It also includes references to related documents and resources.</p> <p>Section 2 provides an overall description of the product, explaining its context, user  characteristics, product features, assumptions, and constraints.</p> <p>Section 3 presents the specific requirements, both functional (such as map filtering, restaurant profiles, user registration, and reviews) and non-functional (usability, reliability, and performance). This section details each feature with pre-conditions and post-conditions where  applicable, ensuring clear expectations for both developers and testers.</p> <p>Section 4 includes supporting information and especially contact information about the team.</p>"},{"location":"docs/general/srs/#2-overall-description","title":"2. Overall Description","text":""},{"location":"docs/general/srs/#a-product-perspective","title":"a. Product perspective","text":"<p>Green Sprout is a restaurant-finder web-based application. The product is intended to serve  as a comprehensive platform for finding, reviewing, and recommending restaurants within  a specific geographic area, such as Karlsruhe. The platform allows users to register as  reviewers, browse restaurants, and filter search results by cuisine type and diet preferences.  They can also create lists with selected restaurants of their choice. The application aims to  provide users with a rich visual interface and interactive map, helping users make informed  dining decisions based on location, ratings, and reviews.</p>"},{"location":"docs/general/srs/#b-class-diagram","title":"b. Class Diagram","text":""},{"location":"docs/general/srs/#c-use-case-diagram","title":"c. Use Case Diagram","text":""},{"location":"docs/general/srs/#d-tech-stack","title":"d. Tech-Stack","text":"Scope Technology Frontend JavaScript Framework (Vue.js) Backend Java Framework (Springboot) Database PostgreSQL Project Management Jira IDE IntelliJ, VSCode Deployment GitHub Actions Testing diverse"},{"location":"docs/general/srs/#e-user-characteristics","title":"e. User characteristics","text":"<p>Reviewers: Registered users who can write reviews, upload images, ratings to restaurants  and create restaurant lists. They are primarily food enthusiasts who want to share their  experiences. General Users: Unregistered users or casual viewers who want to browse restaurants, view  reviews, and explore the map without creating an account.</p>"},{"location":"docs/general/srs/#f-requirement-subsets","title":"f. Requirement subsets","text":"<p>Core Requirements: Features necessary for the minimum viable product (MVP) include the map, restaurant and user profiles, user registration, review submission, and filtering. Additional Features: Future expansions could include the ability to create restaurant lists  and add the ability to filter also for non-restaurant businesses (e.g., bars, shops).</p>"},{"location":"docs/general/srs/#3-specific-requirements","title":"3. Specific Requirements","text":""},{"location":"docs/general/srs/#31-functionality","title":"3.1 Functionality","text":"<p>This section will explain the different use cases as seen in the Use Case diagram and their  functionality 1. Configure map filter This functionality gives the user the possibility to filter for specific keys like cuisines  and diets. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: The user opened the website and is in the initial map view and selected filters. post-conditions: The map displays only the restaurants that match the selected filters. Story points: 13</p> <p>2. View point of interest View point of interest shows the user information about the selected point of interest (e.g restaurant) including name, cuisine, pictures, overall rating and existing reviews. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: Clicked on restaurant marker on the map. post-conditions: Side bar with restaurant information and reviews opens. Story points: 13</p> <p>3. Write review A reviewer has the possibility to write a review for the currently selected restaurant. The review includes a rating and optionally pictures as well a review text. Sequence Diagram:  GUI Mockup:  Activity Diagram: pre-conditions: The user is logged in and on the restaurant's profile page and clicked on \"write review\u201d button. post-conditions: Pop-up window to write review opens. Story points: 21</p> <p>4. Create lists (soon) With this functionality reviewers get the chance to save restaurants in a list. To remember their favorite restaurants or keep track of restaurants they want to visit. Sequence Diagram: coming soon GUI Mockup: coming soon pre-conditions: The user is logged in and has access to the restaurant profiles. post-conditions: The user can create a new list and add restaurants to it, with the option to name the list. Story points: -</p> <p>5. Share list (soon) This functionality provides reviewers the option of sharing their list with other users. Sequence Diagram: coming soon GUI Mockup: coming soon pre-conditions: The user has created at least one list and is logged in. post-conditions: The user can share the list with other users via a link or other sharing options. Story points: -</p> <p>6. Customize list (soon) Reviewers also need the possibility to remove restaurants from their list, change the name of the list or delete it if it's not used anymore. Sequence Diagram: coming soon GUI Mockup: coming soon pre-conditions: The user has an existing list and is logged in. post-conditions: The user can update the list by removing restaurants, changing the list name, or deleting the list entirely. Story points: -</p>"},{"location":"docs/general/srs/#32-usability","title":"3.2 Usability","text":""},{"location":"docs/general/srs/#321-user-training-and-learning-time","title":"3.2.1 User Training and Learning Time","text":"<p>Normal Users (General Visitors and Unregistered Users): The application should be intuitive enough that a new user can browse restaurants, view details, and read reviews with minimal effort. No training should be required, and users should become proficient in basic tasks (e.g., navigating the map, searching restaurants) within a few minutes. Power Users (Registered Reviewers): Reviewers who will frequently submit reviews, upload photos, and manage restaurant lists should become proficient in these more complex tasks after doing them once.</p>"},{"location":"docs/general/srs/#322-task-efficiency","title":"3.2.2 Task Efficiency","text":"<p>Restaurant Search and Filtering: Users should be able to filter restaurant searches by  cuisine type or diet within 5 clicks or taps. The results should update in under 3 seconds on average. Review Submission: Registered users must be able to submit a new review with a star  rating and upload photos in under 3 minutes, assuming an average internet connection.</p>"},{"location":"docs/general/srs/#323-user-interface-ui-standards","title":"3.2.3 User Interface (UI) Standards","text":"<p>The UI should adhere to modern usability standards for web applications, such as providing a consistent layout across all pages, and easy-to-read fonts. Interactive elements (buttons, forms, filters) should be clearly distinguishable with appropriate spacing and color contrast.</p>"},{"location":"docs/general/srs/#324-error-handling-and-feedback","title":"3.2.4 Error Handling and Feedback","text":"<p>Users must receive clear and concise feedback when an error occurs (e.g., invalid form  inputs, failed review submission). The system should provide confirmations for critical actions such as submitting reviews  or creating new restaurant lists.</p>"},{"location":"docs/general/srs/#33-usability","title":"3.3 Usability","text":""},{"location":"docs/general/srs/#331-availability","title":"3.3.1 Availability","text":"<p>The system must be available 97% of the time. Scheduled maintenance windows should be communicated to users in advance.</p>"},{"location":"docs/general/srs/#332-fault-tolerance","title":"3.3.2 Fault Tolerance","text":"<p>The system must be capable of handling unexpected failures in the database, server, or network without causing a complete system shutdown.</p>"},{"location":"docs/general/srs/#333-data-integrity","title":"3.3.3 Data Integrity","text":"<p>The system must ensure that user reviews, restaurant profiles, and other critical data are stored safely, even in the event of hardware failure, power outages, or software crashes. Transaction management and database operations must follow ACID (Atomicity, Consistency, Isolation, Durability) principles to guarantee data integrity.</p>"},{"location":"docs/general/srs/#34-performance","title":"3.4 Performance","text":""},{"location":"docs/general/srs/#341-response-time","title":"3.4.1 Response Time","text":"<p>The system must provide a response time of less than 3 seconds for all major user actions under normal conditions, including: - Searching for restaurants - Viewing restaurant profiles - Submitting reviews and ratings In high load conditions, the response time should not exceed 5 seconds. Actions involving media uploads (e.g., images of restaurants) should complete within 5 seconds for files under 5MB. For larger files, the system should notify users about expected upload time and provide feedback on progress.</p>"},{"location":"docs/general/srs/#342-database-performance","title":"3.4.2 Database Performance","text":"<p>Queries to the database (e.g., fetching restaurant details, reviews, or user profiles) must return results within 2 seconds under normal load and no more than 5 seconds under peak load. Bulk operations, such as batch importing of restaurant data, should complete within 15 minutes.</p>"},{"location":"docs/general/srs/#35-supportability","title":"3.5 Supportability","text":""},{"location":"docs/general/srs/#351-coding-standards","title":"3.5.1 Coding Standards","text":"<p>The Green Sprout project will adhere to clean code principles and industry best practices, ensuring modular, maintainable, and scalable code. All code will follow standard naming conventions, proper indentation, and include sufficient comments to enhance readability and ease future development. Version control (Git) will be used to manage code changes, ensuring traceability and allowing for safe rollbacks when necessary.</p>"},{"location":"docs/general/srs/#352-testing-strategy","title":"3.5.2 Testing Strategy","text":"<p>A comprehensive testing strategy will be implemented, including automated unit tests. All features will undergo testing across different desktop devices and browsers to guarantee compatibility and performance.</p>"},{"location":"docs/general/srs/#36-design-constraints","title":"3.6 Design Constraints","text":"<p>Technology Stack: The application will be built using Vue.js for the frontend, Spring Boot with Java for the backend, and PostgreSQL as the database. These technologies define the framework and limit the design to what is supported by these tools.  </p> <p>Responsiveness: The user interface must be designed to work seamlessly across various desktop devices, adhering to responsive design principles.  </p> <p>Data Storage: The application will store user and restaurant data in a relational database (PostgreSQL), which constrains the design to a schema that ensures efficient querying and data integrity.  </p> <p>Security: All design elements must consider security measures like encrypted  communication (HTTPS), authentication, and secure database access to protect user data and maintain privacy.</p>"},{"location":"docs/general/srs/#37-on-line-user-documentation-and-help-system-requirements","title":"3.7 On-line User Documentation and Help System Requirements","text":"<p>The usage of the web application should be as intuitive as possible so it won't need any further documentation. If the user needs some help they should be able to contact the development team.</p>"},{"location":"docs/general/srs/#38-purchased-components","title":"3.8 Purchased Components","text":"<p>We don't have any purchased components yet. If there will be purchased components in the future we will list them here.</p>"},{"location":"docs/general/srs/#39-interfaces","title":"3.9 Interfaces","text":"<p>The user interfaces to be implemented are:</p> <ul> <li>Home Page \u2013 Displays a map with restaurant markers, search options, and featured restaurants.</li> <li>Restaurant Profile Page \u2013 Shows detailed information about a restaurant, including images, reviews, ratings, and location.</li> <li>User Profile Page \u2013 Displays user information, reviews they\u2019ve written, favorite restaurants, and preferences.</li> <li>Login Page \u2013 Allows users to log into the platform.</li> <li>Register Page \u2013 Provides a registration form for new users to sign up.</li> <li>Review Submission Page \u2013 Allows users to submit reviews and ratings for restaurants, including uploading images.</li> <li>Create a List Page \u2013 Allows users to create a new list from a collection of chosen restaurants.</li> <li>View a List Page - Allows users to view own/ shared lists and its contents</li> </ul>"},{"location":"docs/general/srs/#391-hardware-interfaces","title":"3.9.1 Hardware Interfaces","text":"<p>n/a</p>"},{"location":"docs/general/srs/#392-software-interfaces","title":"3.9.2 Software Interfaces","text":"<p>This application will be runnable on desktop browsers (Chrome, Edge, Safari, Firefox, etc.).</p>"},{"location":"docs/general/srs/#393-communications-interfaces","title":"3.9.3 Communications Interfaces","text":"<p>The server and browser will communicate using https protocol.</p>"},{"location":"docs/general/srs/#310-architecturally-significant-requirements","title":"3.10 Architecturally Significant Requirements","text":"Quality attribute Refinement Quality attribute scenarios Business value Technical risk Aesthetics Design The design is centered around meeting user needs with a cohesive, green-themed design system. Visual elements are consistently styled to ensure a unified look and feel across the interface. Interactive elements, such as buttons, provide immediate feedback for example color change, giving users a clear confirmation of their actions and enhancing the overall user experience. H L Conformance Ease of Deployment Deploying a new version of a component should be made simple by providing sufficient resources to the deployer. The new component must be backward compatible to ensure stable conversion to newer program versions. M L Performance Response Time The application, especially in terms of communication with the backend and API, should maintain a response time under 2 seconds. Ideally, it should stay within the 1-second range to ensure a seamless user experience. H M Page Speed A user, no matter what device, should see a visually appealing and fast page. A google page speed insight analysis of at least 90 points is considered to be good H L Serviceability Modularity Backend, Frontend &amp; Database should be seperated at any given time. Sections should be kept structured to allow adding further Feature-Modules at a later point. M M Security User-Data-Encryption By hashing the password of a user immediately after recieving it in the backend, and only storing this hash guarantees the security of the password. The authentication of all user requests and their integrity is verified by using industry-standard JWT tokens. H H"},{"location":"docs/general/srs/#311-licensing-requirements","title":"3.11 Licensing Requirements","text":"<p>n/a</p>"},{"location":"docs/general/srs/#312-legal-copyright-and-other-notices","title":"3.12 Legal, Copyright, and Other Notices","text":"<p>We do not take responsibility for any incorrect data or errors in the application.</p>"},{"location":"docs/general/srs/#313-applicable-standards","title":"3.13 Applicable Standards","text":"<p>The development will follow the common clean code standards and naming conventions (see section 3.5.1 Coding standards).</p>"},{"location":"docs/general/srs/#4-supporting-information","title":"4. Supporting Information","text":"<p>For any further information you can contact the Green Sprout Team or check our Green Sprout Blog The Team Members are: - Paula Kropfinger - Valentin W\u00f6hrle - Jonas Schl\u00f6sser - Samuel Brekeller - Safae Kartite</p>"},{"location":"docs/sprintmeetings/sprint2/","title":"Sprintmeeting 2","text":"<p>Sprint 22.10.2024 bis 05.11.2024 </p>"}]}